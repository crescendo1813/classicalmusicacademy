<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crescendo Classical Music Academy - Member Login</title>
    <style>
        /* Alap st√≠lusok */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            overflow-x: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Login container */
        .login-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 40px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .login-title {
            font-size: 28px;
            margin-bottom: 10px;
            color: #ffd93d;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .login-subtitle {
            font-size: 16px;
            margin-bottom: 30px;
            color: #a5b4fc;
        }

        .music-icon {
            font-size: 60px;
            margin-bottom: 20px;
            color: #ffd93d;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Form elements */
        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #a5b4fc;
        }

        input[type="text"],
        input[type="password"] {
            width: 100%;
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            box-sizing: border-box;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        input[type="text"]:focus,
        input[type="password"]:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: #ffd93d;
        }

        .login-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: #ffd93d;
            color: #333;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .login-btn:hover {
            background: #ffc107;
            transform: translateY(-2px);
        }

        .error-message {
            color: #ff6b6b;
            margin-top: 15px;
            font-size: 14px;
            display: none;
        }

        /* Main content (hidden initially) */
        #main-content {
            display: none;
            width: 100%;
            padding: 20px;
        }

        /* St√≠lusok a f≈ë tartalomhoz */
        .main-body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #111;
            color: white;
            overflow-x: hidden;
        }
        
        h1 {
            color: #ff6b6b;
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            text-align: center;
            color: #a5b4fc;
            margin-bottom: 20px;
            font-size: 16px;
        }

        /* Gombok */
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 20px;
            border: none;
            background: #222;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid #444;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #333;
            transform: translateY(-2px);
        }

        .start-btn {
            border-color: #4CAF50;
            background: #2d5a2d;
        }

        .stop-btn {
            border-color: #f44336;
            background: #5a2d2d;
        }

        .load-btn {
            border-color: #2196F3;
            background: #2d3c5a;
        }

        .graceful-btn {
            border-color: #FF9800;
            background: #5a472d;
        }

        /* Timer display */
        .timer-container {
            text-align: center;
            margin: 20px 0;
        }

        .timer {
            font-size: 48px;
            font-weight: bold;
            color: #ffd93d;
            margin: 10px 0;
        }

        .timer-label {
            font-size: 16px;
            color: #a5b4fc;
        }

        /* Graceful shutdown timer */
        .graceful-timer {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid #FF9800;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            display: none;
        }

        .graceful-title {
            font-size: 16px;
            color: #ffd93d;
            margin-bottom: 10px;
        }

        .graceful-time {
            font-size: 24px;
            font-weight: bold;
            color: #FF9800;
            margin: 10px 0;
        }

        /* Batch progress */
        .batch-progress {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
        }

        .batch-step {
            text-align: center;
            flex: 1;
            padding: 10px;
            position: relative;
        }

        .batch-step.active {
            color: #ffd93d;
        }

        .batch-step.completed {
            color: #4CAF50;
        }

        .batch-step::after {
            content: '';
            position: absolute;
            top: 50%;
            right: 0;
            width: 100%;
            height: 2px;
            background: #333;
            z-index: -1;
        }

        .batch-step:last-child::after {
            display: none;
        }

        .batch-step.active::after {
            background: #ffd93d;
        }

        .batch-step.completed::after {
            background: #4CAF50;
        }

        /* Stats */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
            font-size: 14px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ffd93d;
            margin: 5px 0;
        }

        .stat-label {
            font-size: 12px;
            color: #a5b4fc;
        }

        /* Rekl√°m statisztik√°k */
        .ad-stats {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-size: 14px;
        }

        .ad-title {
            font-size: 16px;
            color: #ffd93d;
            margin-bottom: 10px;
        }

        /* Progress bar */
        .progress-container {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #ffd93d);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Status message */
        .status {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-size: 16px;
            border-left: 4px solid #ff6b6b;
        }

        /* Playback statistics */
        .playback-stats {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .playback-title {
            font-size: 16px;
            color: #ffd93d;
            margin-bottom: 10px;
            text-align: center;
        }

        .playback-info {
            font-size: 14px;
            color: #a5b4fc;
            text-align: center;
        }

        .tip {
            font-size: 12px;
            color: #666;
            margin-top: 20px;
            text-align: center;
            line-height: 1.5;
        }

        .loading {
            text-align: center;
            color: #ffd93d;
            margin: 20px 0;
            font-size: 14px;
        }

        /* √öj v√©delmi indik√°torok */
        .security-indicators {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .security-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid;
            font-size: 12px;
        }

        .security-card.safe {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .security-card.warning {
            border-color: #ff9800;
            background: rgba(255, 152, 0, 0.1);
        }

        .security-card.danger {
            border-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        .risk-monitor {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #ff6b6b;
        }

        .risk-level {
            height: 10px;
            background: linear-gradient(90deg, #4CAF50, #ff9800, #f44336);
            border-radius: 5px;
            margin: 10px 0;
            position: relative;
        }

        .risk-indicator {
            position: absolute;
            top: -2px;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            transform: translateX(-50%);
            transition: left 0.5s ease;
        }

        /* Mem√≥ria monitor */
        .memory-monitor {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4CAF50;
        }

        .memory-title {
            font-size: 16px;
            color: #ffd93d;
            margin-bottom: 10px;
            text-align: center;
        }

        .memory-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .memory-stat {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .memory-value {
            font-size: 18px;
            font-weight: bold;
            color: #ffd93d;
            margin: 5px 0;
        }

        .memory-label {
            font-size: 11px;
            color: #a5b4fc;
        }

        .memory-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .memory-usage {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #ff9800, #f44336);
            width: 0%;
            transition: width 0.5s ease;
        }

        .cleanup-alert {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            text-align: center;
            font-size: 12px;
            display: none;
        }

        /* Stealth monitor */
        .stealth-monitor {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #9C27B0;
        }

        .stealth-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .stealth-metric {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .stealth-status {
            text-align: center;
            font-size: 14px;
            color: #a5b4fc;
            margin-top: 10px;
        }

        /* Vide√≥s player kont√©ner - WEBOLDAL R√âSZEK√âNT */
        .video-container {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #2196F3;
        }

        .video-title {
            font-size: 16px;
            color: #ffd93d;
            margin-bottom: 10px;
            text-align: center;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .video-player {
            background: #000;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
            border: 1px solid #444;
        }

        .video-player:hover {
            transform: translateY(-3px);
        }

        .player-container {
            width: 100%;
            height: 180px; /* N√∂velt magass√°g a rekl√°mok kattinthat√≥s√°g√°hoz */
            background: #000;
            cursor: pointer;
            position: relative;
        }

        .video-info {
            padding: 8px;
            font-size: 10px;
            color: #a5b4fc;
            text-align: center;
        }

        .ad-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 193, 7, 0.9);
            color: #000;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
        }

        .click-status {
            position: absolute;
            bottom: 25px;
            left: 5px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: bold;
        }

        /* Popup ablak */
        .ad-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            height: 70vh;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 10000;
            display: none;
        }

        .popup-header {
            background: #333;
            color: white;
            padding: 10px 15px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .popup-content {
            width: 100%;
            height: calc(100% - 50px);
            border: none;
            border-radius: 0 0 10px 10px;
        }

        .close-popup {
            background: #ff4444;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 9999;
            display: none;
        }

        /* √öj debug st√≠lusok */
        .debug-panel {
            background: rgba(255, 0, 0, 0.1);
            border: 2px solid #f44336;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 12px;
        }
        
        .debug-title {
            color: #f44336;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .debug-info {
            color: #ff9800;
            margin: 5px 0;
        }
        
        .debug-error {
            color: #f44336;
            font-weight: bold;
        }
        
        .debug-success {
            color: #4CAF50;
        }
        
        .element-state {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 8px;
            z-index: 1000;
        }
        
        /* Batch bet√∂lt√©s gomb */
        .batch-controls {
            text-align: center;
            margin: 20px 0;
        }
        
        /* Fingerprint display */
        .fingerprint-info {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 12px;
            text-align: center;
        }

        /* Profi v√©delmi elemek */
        .advanced-protection {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #00BCD4;
        }

        .protection-title {
            font-size: 16px;
            color: #ffd93d;
            margin-bottom: 10px;
            text-align: center;
        }

        .protection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .protection-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            font-size: 12px;
        }

        .protection-status {
            font-weight: bold;
            margin-top: 5px;
        }

        .protection-status.active {
            color: #4CAF50;
        }

        .protection-status.inactive {
            color: #f44336;
        }

        /* Traffic simulation */
        .traffic-simulation {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #FF5722;
        }

        .traffic-title {
            font-size: 16px;
            color: #ffd93d;
            margin-bottom: 10px;
            text-align: center;
        }

        .traffic-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .traffic-stat {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .traffic-value {
            font-size: 18px;
            font-weight: bold;
            color: #ffd93d;
            margin: 5px 0;
        }

        .traffic-label {
            font-size: 11px;
            color: #a5b4fc;
        }

        /* Error states */
        .error-state {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }

        .warning-state {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid #ff9800;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }

        .loading-state {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid #2196F3;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Popup ablak rekl√°mokhoz -->
    <div class="popup-overlay" id="popupOverlay"></div>
    <div class="ad-popup" id="adPopup">
        <div class="popup-header">
            <span>Advertisement</span>
            <button class="close-popup" id="closePopup">Close</button>
        </div>
        <iframe class="popup-content" id="popupContent" src="about:blank"></iframe>
    </div>

    <!-- Login Section -->
    <div id="login-section" class="login-container">
        <div class="music-icon">üéµ</div>
        <h1 class="login-title">Crescendo Classical Music Academy</h1>
        <p class="login-subtitle">Access restricted to academy members only</p>
        
        <form id="login-form">
            <div class="form-group">
                <label for="username">Username</label>
                <input type="text" id="username" placeholder="Enter your username" required>
            </div>
            
            <div class="form-group">
                <label for="password">Password</label>
                <input type="password" id="password" placeholder="Enter your password" required>
            </div>
            
            <button type="submit" class="login-btn">Login to Academy Portal</button>
            
            <div id="error-message" class="error-message">
                Invalid credentials. Please try again.
            </div>
        </form>
    </div>

    <!-- Main Content (Hidden until login) -->
    <div id="main-content" class="main-body">
        <div id="am-experiment">
            <h1>üé¨ Video Zone Experiment - Manual Control</h1>
            <p class="subtitle">Video players + Ads + Manual start + Full functionality</p>

            <!-- Rekl√°m statisztik√°k FEL√úL -->
            <div class="ad-stats">
                <div class="ad-title">üìä Advertisement Statistics</div>
                <div>Total ads: <span id="totalAds">0</span> | Successful ads: <span id="successfulAds">0</span></div>
                <div>Estimated ad revenue: $<span id="adRevenue">0.00</span></div>
            </div>

            <!-- V√©delmi indik√°torok -->
            <div class="security-indicators">
                <div class="security-card safe" id="patternCard">
                    <div>üéØ Launch Pattern</div>
                    <div>Manual</div>
                </div>
                <div class="security-card safe" id="timingCard">
                    <div>‚è±Ô∏è Timing</div>
                    <div>User controlled</div>
                </div>
                <div class="security-card safe" id="behaviorCard">
                    <div>üë§ Behavior</div>
                    <div>Human</div>
                </div>
                <div class="security-card safe" id="riskCard">
                    <div>üõ°Ô∏è Risk</div>
                    <div>Low</div>
                </div>
            </div>

            <!-- DEBUG PANEL -->
            <div class="debug-panel">
                <div class="debug-title">üîç DEBUG PANEL - Manual Mode</div>
                <div class="debug-info" id="debugClickStatus">Mode: Manual click</div>
                <div class="debug-info" id="debugElementState">Element state: Waiting for manual start</div>
                <div class="debug-info" id="debugEventStatus">Event status: User interaction</div>
                <div class="debug-info" id="debugFrameStatus">IFrame status: Ready</div>
                <div class="debug-info" id="debugTimingStatus">Timing: No automatic</div>
            </div>

            <!-- Graci√°lis le√°ll√°s timer -->
            <div class="graceful-timer" id="gracefulTimer">
                <div class="graceful-title">üïê Graceful Shutdown Active</div>
                <div class="graceful-time" id="gracefulTime">--:--</div>
                <div id="gracefulStatus">Videos are gradually stopping...</div>
            </div>

            <!-- Profi v√©delmi elemek -->
            <div class="advanced-protection">
                <div class="protection-title">üõ°Ô∏è Professional Hacker Protection System</div>
                <div class="protection-grid">
                    <div class="protection-item">
                        <div>üåê IP Rotation</div>
                        <div class="protection-status active" id="ipRotationStatus">Active</div>
                    </div>
                    <div class="protection-item">
                        <div>üîí Traffic Encryption</div>
                        <div class="protection-status active" id="trafficEncryptionStatus">Active</div>
                    </div>
                    <div class="protection-item">
                        <div>üîÑ User Agent Randomization</div>
                        <div class="protection-status active" id="userAgentStatus">Active</div>
                    </div>
                    <div class="protection-item">
                        <div>üì± Device Simulation</div>
                        <div class="protection-status active" id="deviceSimulationStatus">Active</div>
                    </div>
                    <div class="protection-item">
                        <div>üåç Geolocation Masking</div>
                        <div class="protection-status active" id="geolocationStatus">Active</div>
                    </div>
                    <div class="protection-item">
                        <div>‚è∞ Timezone Manipulation</div>
                        <div class="protection-status active" id="timezoneStatus">Active</div>
                    </div>
                    <div class="protection-item">
                        <div>üé≠ Canvas Fingerprint Spoofing</div>
                        <div class="protection-status active" id="canvasSpoofingStatus">Active</div>
                    </div>
                    <div class="protection-item">
                        <div>üîç WebRTC Blocking</div>
                        <div class="protection-status active" id="webrtcStatus">Active</div>
                    </div>
                </div>
            </div>

            <!-- Forgalom szimul√°ci√≥ -->
            <div class="traffic-simulation">
                <div class="traffic-title">üåê Traffic Simulation & IP Masking</div>
                <div class="traffic-stats">
                    <div class="traffic-stat">
                        <div class="traffic-value" id="currentIP">192.168.1.1</div>
                        <div class="traffic-label">Current IP</div>
                    </div>
                    <div class="traffic-stat">
                        <div class="traffic-value" id="requestCount">0</div>
                        <div class="traffic-label">Requests</div>
                    </div>
                    <div class="traffic-stat">
                        <div class="traffic-value" id="sessionTime">00:00</div>
                        <div class="traffic-label">Session</div>
                    </div>
                    <div class="traffic-stat">
                        <div class="traffic-value" id="fingerprintCount">0</div>
                        <div class="traffic-label">Fingerprints</div>
                    </div>
                </div>
            </div>

            <!-- Kock√°zat monitor -->
            <div class="risk-monitor">
                <div style="text-align: center; color: #ffd93d; margin-bottom: 10px;">
                    üéõÔ∏è Behavior Monitor - Manual mode
                </div>
                <div class="risk-level">
                    <div class="risk-indicator" id="riskIndicator" style="left: 5%;"></div>
                </div>
                <div style="display: flex; justify-content: space-between; font-size: 12px; color: #a5b4fc;">
                    <span>Low</span>
                    <span>Medium</span>
                    <span>High</span>
                </div>
                <div id="riskStatus" style="text-align: center; margin-top: 10px; font-size: 14px;">
                    ‚úÖ All parameters optimal - Manual mode
                </div>
            </div>

            <!-- Mem√≥ria Monitor -->
            <div class="memory-monitor">
                <div class="memory-title">üß† Memory Monitor - Manual Mode</div>
                <div class="memory-info">
                    <div class="memory-stat">
                        <div class="memory-value" id="memoryUsage">0 MB</div>
                        <div class="memory-label">Usage</div>
                    </div>
                    <div class="memory-stat">
                        <div class="memory-value" id="memoryLimit">0 MB</div>
                        <div class="memory-label">Limit</div>
                    </div>
                    <div class="memory-stat">
                        <div class="memory-value" id="memoryPercent">0%</div>
                        <div class="memory-label">Utilization</div>
                    </div>
                    <div class="memory-stat">
                        <div class="memory-value" id="cleanupCount">0</div>
                        <div class="memory-label">Cleanups</div>
                    </div>
                </div>
                <div class="memory-bar">
                    <div class="memory-usage" id="memoryBar"></div>
                </div>
                <div class="cleanup-alert" id="cleanupAlert">
                    üö® High memory usage! Automatic cleanup active...
                </div>
                <div style="text-align: center; font-size: 12px; color: #a5b4fc; margin-top: 10px;">
                    ‚ö° Automatic cleanup: above 70% | üîÑ Manual: 
                    <button id="manualCleanup" style="padding: 4px 8px; font-size: 10px; margin-left: 5px;">Force Cleanup</button>
                </div>
            </div>

            <!-- Stealth Monitor -->
            <div class="stealth-monitor">
                <div style="text-align: center; color: #ffd93d; margin-bottom: 10px;">
                    üïµÔ∏è‚Äç‚ôÇÔ∏è Advanced Anti-Detection Monitor - Manual Mode
                </div>
                <div class="stealth-metrics">
                    <div class="stealth-metric">
                        <span>Strategy:</span>
                        <span id="currentStrategy">manual</span>
                    </div>
                    <div class="stealth-metric">
                        <span>User Agent:</span>
                        <span id="currentUA">Stable</span>
                    </div>
                    <div class="stealth-metric">
                        <span>Timezone:</span>
                        <span id="currentTZ">Local</span>
                    </div>
                    <div class="stealth-metric">
                        <span>Playback Profile:</span>
                        <span id="currentProfile">Manual</span>
                    </div>
                </div>
                <div class="stealth-status" id="stealthStatus">
                    ‚úÖ Anti-Detection active - Manual mode
                </div>
            </div>

            <!-- F≈ë vez√©rl≈ëk -->
            <div class="controls">
                <button class="load-btn" id="loadBatchButton">
                    üì• Load Batch
                </button>
                <button class="graceful-btn" id="gracefulShutdownButton">
                    üïê Graceful Shutdown (5-8 minutes)
                </button>
                <button class="stop-btn" id="stopButton">
                    ‚èπÔ∏è Stop All
                </button>
            </div>

            <!-- Timer -->
            <div class="timer-container">
                <div class="timer" id="timer">--:--</div>
                <div class="timer-label" id="timerLabel">Manual mode - No timing</div>
            </div>

            <!-- Batch progress -->
            <div class="batch-progress" id="batchProgressContainer">
                <!-- Dinamikusan gener√°l√≥dik -->
            </div>
            
            <!-- Batch bet√∂lt√©s gomb -->
            <div class="batch-controls">
                <button class="load-btn" id="nextBatchButton">
                    üîÑ Load Next Batch
                </button>
            </div>

            <!-- Stats -->
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="readyCount">0</div>
                    <div class="stat-label">Loaded Players</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="activeCount">0</div>
                    <div class="stat-label">Active Videos</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalCount">389</div>
                    <div class="stat-label">Total Zones</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="currentBatch">-</div>
                    <div class="stat-label">Active Batch</div>
                </div>
            </div>

            <!-- Progress bar -->
            <div class="progress-container">
                <div class="progress-bar" id="loadProgress"></div>
            </div>

            <!-- Playback statistics -->
            <div class="playback-stats">
                <div class="playback-title">üìä Playback Statistics</div>
                <div class="playback-info">
                    <div id="playbackCount">Total playbacks: 0</div>
                    <div id="monthlyStats">Monthly breakdown:</div>
                </div>
            </div>

            <!-- Ujjlenyomat inform√°ci√≥k -->
            <div class="fingerprint-info" id="fingerprintInfo">
                Unique fingerprint generated for each video
            </div>

            <!-- Status √ºzenet -->
            <div class="status" id="statusMessage">
                Click the "Load Batch" button to display videos!
            </div>

            <!-- Loading -->
            <div class="loading" id="loadingMessage" style="display: none;">
                Loading players...
            </div>

            <!-- Error states container -->
            <div id="errorStatesContainer"></div>

            <p class="tip">
                ‚úÖ 389 zones in dynamic batches (60-80 zones/batch)<br>
                üñ±Ô∏è Manual start - every video must be started manually<br>
                üì• Manual batch loading - on button press<br>
                üé¨ Video players - ads active<br>
                üí∞ Ad revenue tracking - estimated income<br>
                üõ°Ô∏è Behavior Monitor - real-time risk assessment<br>
                üß† Memory Monitor - automatic cleanup above 70% RAM<br>
                üïµÔ∏è‚Äç‚ôÇÔ∏è Advanced Anti-Detection - hiding from YouTube algorithm<br>
                üìä Statistics - tracking playback counts<br>
                üîÄ Links randomly shuffled after each cycle<br>
                üåê Browser fingerprint manipulation<br>
                üîç Advanced diagnostic system - Real-time debug<br>
                üïê New: Graceful shutdown - 5-8 minute countdown<br>
                üîë New: Unique fingerprint generation for each video<br>
                üõ°Ô∏è New: Professional Hacker Protection System - IP rotation, traffic encryption<br>
                üåç New: Geolocation masking, timezone manipulation<br>
                üì± New: Device simulation, User Agent randomization<br>
                üîí New: WebRTC blocking, Canvas fingerprint spoofing<br>
                ü™ü New: Ad click popup windows<br>
                üì∫ New: Larger video size for better ad visibility
            </p>
        </div>

        <!-- Vide√≥s Player Kont√©ner - WEBOLDAL ALJ√ÅRA -->
        <div class="video-container">
            <div class="video-title">üé¨ Videos - Manual start</div>
            <div class="video-grid" id="videoGrid">
                <!-- Vide√≥k ide ker√ºlnek dinamikusan -->
            </div>
        </div>
    </div>

    <!-- YouTube IFrame API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    
    <script>
        // ========== KONFIGUR√ÅCI√ìS OBJEKTUM ==========
        const CONFIG = {
            // Bel√©p√©si adatok
            CREDENTIALS: {
                USERNAME: "Zonebooster",
                PASSWORD: "Newmate@1989"
            },
            
            // Batch konfigur√°ci√≥
            BATCH: {
                MIN_SIZE: 60,
                MAX_SIZE: 80,
                TARGET_TOTAL: 389,
                LOAD_DELAY: 100 // Player bet√∂lt√©si k√©sleltet√©s
            },
            
            // Mem√≥ria konfigur√°ci√≥
            MEMORY: {
                CLEANUP_THRESHOLD: 0.7,
                MONITOR_INTERVAL: 2000,
                AGGRESSIVE_CLEANUP: true
            },
            
            // Graci√°lis le√°ll√°s
            GRACEFUL_SHUTDOWN: {
                MIN_DURATION: 5 * 60 * 1000,
                MAX_DURATION: 8 * 60 * 1000
            },
            
            // V√©delmi konfigur√°ci√≥
            PROTECTION: {
                IP_ROTATION_INTERVAL: 30000,
                USER_AGENT_ROTATION_INTERVAL: 45000,
                TRAFFIC_SIMULATION_INTERVAL: 15000,
                FINGERPRINT_ROTATION_INTERVAL: 60000
            },
            
            // YouTube API konfigur√°ci√≥
            YOUTUBE: {
                PLAYER_VARS: {
                    'playsinline': 1,
                    'enablejsapi': 1,
                    'origin': window.location.origin,
                    'rel': 0,
                    'modestbranding': 1,
                    'controls': 1,
                    'showinfo': 0,
                    'iv_load_policy': 3,
                    'autoplay': 0,
                    'fs': 0
                },
                MAX_RETRY_ATTEMPTS: 3,
                RETRY_DELAY: 1000
            },
            
            // Rekl√°m weboldalak
            AD_WEBSITES: [
                "https://www.amazon.com",
                "https://www.ebay.com", 
                "https://www.walmart.com",
                "https://www.bestbuy.com",
                "https://www.target.com",
                "https://www.apple.com",
                "https://www.microsoft.com",
                "https://www.cnn.com",
                "https://www.foxnews.com",
                "https://www.nytimes.com"
            ],
            
            // USA IP c√≠mek
            USA_IPS: [
                "104.32.144.12", "23.235.37.133", "104.156.87.133", "23.235.33.133",
                "104.32.145.12", "23.235.37.134", "104.156.87.134", "23.235.33.134",
                "172.217.6.142", "216.58.194.174", "157.240.2.35", "31.13.71.36",
                "192.0.73.2", "192.0.72.2", "104.16.248.249", "104.16.249.249"
            ],
            
            // USA User Agent-ek
            USA_USER_AGENTS: [
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15',
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0',
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',
                'Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1'
            ],
            
            // USA id≈ëz√≥n√°k
            USA_TIMEZONES: [
                'America/New_York', 'America/Chicago', 'America/Denver', 'America/Los_Angeles',
                'America/Phoenix', 'America/Anchorage', 'Pacific/Honolulu'
            ],
            
            // USA nyelvek
            USA_LANGUAGES: ['en-US', 'en', 'es-US']
        };

        // ========== LOGGING RENDSZER ==========
        const Logger = {
            enabled: true,
            level: 'INFO', // DEBUG, INFO, WARN, ERROR
            
            debug: function(message, data = null) {
                if (this.enabled && this._shouldLog('DEBUG')) {
                    console.debug(`üîß [DEBUG] ${message}`, data || '');
                }
            },
            
            info: function(message, data = null) {
                if (this.enabled && this._shouldLog('INFO')) {
                    console.info(`‚ÑπÔ∏è [INFO] ${message}`, data || '');
                }
            },
            
            warn: function(message, data = null) {
                if (this.enabled && this._shouldLog('WARN')) {
                    console.warn(`‚ö†Ô∏è [WARN] ${message}`, data || '');
                    this._showUserWarning(message);
                }
            },
            
            error: function(message, error = null) {
                if (this.enabled && this._shouldLog('ERROR')) {
                    console.error(`üö® [ERROR] ${message}`, error || '');
                    this._showUserError(message, error);
                }
            },
            
            _shouldLog: function(level) {
                const levels = ['DEBUG', 'INFO', 'WARN', 'ERROR'];
                return levels.indexOf(level) >= levels.indexOf(this.level);
            },
            
            _showUserWarning: function(message) {
                this._showUserMessage(message, 'warning');
            },
            
            _showUserError: function(message, error) {
                const fullMessage = error ? `${message}: ${error.message || error}` : message;
                this._showUserMessage(fullMessage, 'error');
            },
            
            _showUserMessage: function(message, type) {
                const container = document.getElementById('errorStatesContainer');
                if (!container) return;
                
                const messageElement = document.createElement('div');
                messageElement.className = type === 'error' ? 'error-state' : 'warning-state';
                messageElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                
                container.appendChild(messageElement);
                
                // Auto-remove after 10 seconds
                setTimeout(() => {
                    if (messageElement.parentNode) {
                        messageElement.parentNode.removeChild(messageElement);
                    }
                }, 10000);
            }
        };

        // ========== MEM√ìRIAKEZEL≈ê RENDSZER ==========
        const MemoryManager = {
            intervals: new Set(),
            timeouts: new Set(),
            eventListeners: new Map(),
            players: new Map(),
            
            trackInterval: function(intervalId) {
                this.intervals.add(intervalId);
                return intervalId;
            },
            
            trackTimeout: function(timeoutId) {
                this.timeouts.add(timeoutId);
                return timeoutId;
            },
            
            trackEventListener: function(element, event, handler) {
                const key = `${element.id}-${event}`;
                if (!this.eventListeners.has(key)) {
                    this.eventListeners.set(key, []);
                }
                this.eventListeners.get(key).push(handler);
            },
            
            trackPlayer: function(playerId, player) {
                this.players.set(playerId, player);
            },
            
            cleanupAll: function() {
                Logger.info('Starting comprehensive memory cleanup');
                
                // Clear intervals
                this.intervals.forEach(intervalId => {
                    clearInterval(intervalId);
                });
                this.intervals.clear();
                
                // Clear timeouts
                this.timeouts.forEach(timeoutId => {
                    clearTimeout(timeoutId);
                });
                this.timeouts.clear();
                
                // Remove event listeners
                this.eventListeners.forEach((handlers, key) => {
                    const [elementId, event] = key.split('-');
                    const element = document.getElementById(elementId);
                    if (element) {
                        handlers.forEach(handler => {
                            element.removeEventListener(event, handler);
                        });
                    }
                });
                this.eventListeners.clear();
                
                // Destroy players
                this.players.forEach((player, playerId) => {
                    try {
                        if (player && typeof player.destroy === 'function') {
                            player.destroy();
                        }
                    } catch (error) {
                        Logger.error(`Error destroying player ${playerId}`, error);
                    }
                });
                this.players.clear();
                
                Logger.info('Memory cleanup completed');
            }
        };

        // ========== ERROR HANDLER RENDSZER ==========
        const ErrorHandler = {
            initialize: function() {
                window.addEventListener('error', this.handleGlobalError.bind(this));
                window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));
            },
            
            handleGlobalError: function(event) {
                const error = event.error || new Error(event.message);
                Logger.error('Global error occurred', error);
                return false;
            },
            
            handleUnhandledRejection: function(event) {
                Logger.error('Unhandled promise rejection', event.reason);
            },
            
            safeExecute: function(fn, context = null, ...args) {
                try {
                    return fn.apply(context, args);
                } catch (error) {
                    Logger.error(`Error in ${fn.name || 'anonymous function'}`, error);
                    return null;
                }
            },
            
            async safeAsyncExecute(fn, context = null, ...args) {
                try {
                    return await fn.apply(context, args);
                } catch (error) {
                    Logger.error(`Async error in ${fn.name || 'anonymous function'}`, error);
                    return null;
                }
            }
        };

        // ========== ADATVALID√ÅCI√ì RENDSZER ==========
        const DataValidator = {
            validateYouTubeId: function(videoId) {
                if (typeof videoId !== 'string') return false;
                if (videoId.length < 8 || videoId.length > 20) return false;
                return /^[a-zA-Z0-9_-]+$/.test(videoId);
            },
            
            validateUrl: function(url) {
                try {
                    new URL(url);
                    return true;
                } catch {
                    return false;
                }
            },
            
            sanitizeHTML: function(str) {
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
            },
            
            validateStorageData: function(data) {
                try {
                    const parsed = JSON.parse(data);
                    return typeof parsed === 'object' && parsed !== null;
                } catch {
                    return false;
                }
            }
        };

        // ========== ADATMENT≈ê RENDSZER ==========
        const DataManager = {
            STORAGE_KEYS: {
                PLAYBACK_STATS: 'playbackStats_v2',
                APP_STATE: 'appState_v2'
            },
            
            savePlaybackStats: function(stats) {
                try {
                    if (!this._validatePlaybackStats(stats)) {
                        Logger.warn('Invalid playback stats data, not saving');
                        return false;
                    }
                    
                    const data = {
                        ...stats,
                        _version: '2.0',
                        _lastSaved: new Date().toISOString()
                    };
                    
                    localStorage.setItem(this.STORAGE_KEYS.PLAYBACK_STATS, JSON.stringify(data));
                    Logger.debug('Playback stats saved successfully');
                    return true;
                } catch (error) {
                    Logger.error('Failed to save playback stats', error);
                    return false;
                }
            },
            
            loadPlaybackStats: function() {
                try {
                    const data = localStorage.getItem(this.STORAGE_KEYS.PLAYBACK_STATS);
                    if (!data) return this._getDefaultPlaybackStats();
                    
                    if (!DataValidator.validateStorageData(data)) {
                        Logger.warn('Corrupted playback stats data, using defaults');
                        return this._getDefaultPlaybackStats();
                    }
                    
                    const parsed = JSON.parse(data);
                    if (!this._validatePlaybackStats(parsed)) {
                        Logger.warn('Invalid playback stats structure, using defaults');
                        return this._getDefaultPlaybackStats();
                    }
                    
                    Logger.debug('Playback stats loaded successfully');
                    return parsed;
                } catch (error) {
                    Logger.error('Failed to load playback stats', error);
                    return this._getDefaultPlaybackStats();
                }
            },
            
            _validatePlaybackStats: function(stats) {
                return stats && 
                       typeof stats.totalPlaybacks === 'number' &&
                       typeof stats.monthlyStats === 'object';
            },
            
            _getDefaultPlaybackStats: function() {
                return {
                    totalPlaybacks: 0,
                    monthlyStats: {},
                    _version: '2.0',
                    _created: new Date().toISOString()
                };
            },
            
            createBackup: function() {
                try {
                    const backup = {
                        playbackStats: this.loadPlaybackStats(),
                        timestamp: new Date().toISOString(),
                        version: '1.0'
                    };
                    
                    localStorage.setItem('backup_' + Date.now(), JSON.stringify(backup));
                    Logger.info('Data backup created successfully');
                    return true;
                } catch (error) {
                    Logger.error('Failed to create data backup', error);
                    return false;
                }
            },
            
            cleanupOldBackups: function() {
                try {
                    const now = Date.now();
                    const oneDay = 24 * 60 * 60 * 1000;
                    
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('backup_')) {
                            const timestamp = parseInt(key.split('_')[1]);
                            if (now - timestamp > 7 * oneDay) { // 7 days old
                                localStorage.removeItem(key);
                                Logger.debug(`Removed old backup: ${key}`);
                            }
                        }
                    }
                } catch (error) {
                    Logger.error('Error cleaning up old backups', error);
                }
            }
        };

        // ========== YOUTUBE PLAYER MANAGER ==========
        const YouTubePlayerManager = {
            players: new Map(),
            retryCounts: new Map(),
            
            createPlayer: async function(videoId, containerId, index) {
                if (!DataValidator.validateYouTubeId(videoId)) {
                    Logger.error(`Invalid YouTube video ID: ${videoId}`);
                    return null;
                }
                
                return new Promise((resolve) => {
                    const retryKey = `${videoId}-${containerId}`;
                    let retryCount = this.retryCounts.get(retryKey) || 0;
                    
                    const createPlayerInstance = () => {
                        try {
                            Logger.debug(`Creating YouTube player for video ${videoId}`);
                            
                            const player = new YT.Player(containerId, {
                                height: '180',
                                width: '100%',
                                videoId: videoId,
                                playerVars: CONFIG.YOUTUBE.PLAYER_VARS,
                                events: {
                                    'onReady': (event) => {
                                        Logger.debug(`YouTube player ${index} ready`);
                                        this.players.set(containerId, event.target);
                                        MemoryManager.trackPlayer(containerId, event.target);
                                        resolve(event.target);
                                    },
                                    'onStateChange': (event) => {
                                        this._handlePlayerStateChange(event, index);
                                    },
                                    'onError': (event) => {
                                        Logger.error(`YouTube player ${index} error`, event.data);
                                        this._handlePlayerError(event, videoId, containerId, index, resolve);
                                    }
                                }
                            });
                            
                            return player;
                        } catch (error) {
                            Logger.error(`Error creating YouTube player ${index}`, error);
                            this._handleCreationError(videoId, containerId, index, resolve);
                            return null;
                        }
                    };
                    
                    const player = createPlayerInstance();
                    if (!player && retryCount < CONFIG.YOUTUBE.MAX_RETRY_ATTEMPTS) {
                        retryCount++;
                        this.retryCounts.set(retryKey, retryCount);
                        Logger.warn(`Retrying player creation (${retryCount}/${CONFIG.YOUTUBE.MAX_RETRY_ATTEMPTS}) for ${videoId}`);
                        
                        MemoryManager.trackTimeout(
                            setTimeout(() => createPlayerInstance(), CONFIG.YOUTUBE.RETRY_DELAY * retryCount)
                        );
                    }
                });
            },
            
            _handlePlayerStateChange: function(event, index) {
                try {
                    // Existing state change handling logic
                    if (event.data === YT.PlayerState.PLAYING) {
                        AppStateManager.incrementActivePlayers();
                        this._updateClickStatus(index, '‚ñ∂Ô∏è Playing', 'rgba(76, 175, 80, 0.9)');
                        StatsManager.addPlayback(1);
                    } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                        AppStateManager.decrementActivePlayers();
                        const status = AppStateManager.isGracefulShutdownActive() ? '‚è∏Ô∏è Graceful' : '‚è∏Ô∏è Paused';
                        this._updateClickStatus(index, status, 'rgba(255, 152, 0, 0.9)');
                    }
                    
                    // Ad state tracking
                    this._trackAdState(event, index);
                } catch (error) {
                    Logger.error(`Error in player state change handler for player ${index}`, error);
                }
            },
            
            _handlePlayerError: function(event, videoId, containerId, index, resolve) {
                Logger.error(`Player ${index} error with video ${videoId}`, event.data);
                resolve(null);
            },
            
            _handleCreationError: function(videoId, containerId, index, resolve) {
                Logger.error(`Failed to create player for video ${videoId} after retries`);
                resolve(null);
            },
            
            _updateClickStatus: function(index, text, background) {
                const clickStatus = document.getElementById(`clickStatus${index}`);
                if (clickStatus) {
                    clickStatus.textContent = text;
                    clickStatus.style.background = background;
                }
            },
            
            _trackAdState: function(event, index) {
                const adIndicator = document.getElementById(`adIndicator${index}`);
                if (!adIndicator) return;
                
                try {
                    switch (event.data) {
                        case YT.PlayerState.AD_PLAYING:
                            adIndicator.style.display = 'block';
                            adIndicator.textContent = 'üì∫ Ad';
                            adIndicator.style.background = 'rgba(255, 193, 7, 0.9)';
                            AdManager.incrementTotalAds();
                            this._setupAdClickHandler(index);
                            break;
                            
                        case YT.PlayerState.PLAYING:
                            if (adIndicator.style.display === 'block') {
                                AdManager.incrementSuccessfulAds();
                                AdManager.addRevenue(0.01);
                            }
                            adIndicator.style.display = 'none';
                            break;
                            
                        case YT.PlayerState.BUFFERING:
                            adIndicator.style.display = 'block';
                            adIndicator.textContent = '‚è≥ Loading';
                            adIndicator.style.background = 'rgba(33, 150, 243, 0.9)';
                            break;
                    }
                } catch (error) {
                    Logger.error(`Error tracking ad state for player ${index}`, error);
                }
            },
            
            _setupAdClickHandler: function(index) {
                const playerContainer = document.getElementById(`playerContainer${index}`);
                if (!playerContainer) return;
                
                const adClickHandler = (e) => {
                    try {
                        const adUrl = AdManager.getRandomAdUrl();
                        AdManager.openAdPopup(adUrl);
                        
                        playerContainer.removeEventListener('click', adClickHandler);
                        
                        const clickStatus = document.getElementById(`clickStatus${index}`);
                        if (clickStatus) {
                            clickStatus.textContent = 'üí∞ Ad Clicked';
                            clickStatus.style.background = 'rgba(156, 39, 176, 0.9)';
                        }
                        
                        Logger.info(`Ad clicked for video ${index + 1}, opening: ${adUrl}`);
                    } catch (error) {
                        Logger.error(`Error in ad click handler for player ${index}`, error);
                    }
                };
                
                playerContainer.addEventListener('click', adClickHandler);
                MemoryManager.trackEventListener(playerContainer, 'click', adClickHandler);
                
                MemoryManager.trackTimeout(
                    setTimeout(() => {
                        playerContainer.removeEventListener('click', adClickHandler);
                    }, 30000)
                );
            },
            
            destroyPlayer: function(containerId) {
                try {
                    const player = this.players.get(containerId);
                    if (player && typeof player.destroy === 'function') {
                        player.destroy();
                        Logger.debug(`Destroyed YouTube player: ${containerId}`);
                    }
                    this.players.delete(containerId);
                } catch (error) {
                    Logger.error(`Error destroying YouTube player: ${containerId}`, error);
                }
            },
            
            destroyAllPlayers: function() {
                Logger.info('Destroying all YouTube players');
                this.players.forEach((player, containerId) => {
                    this.destroyPlayer(containerId);
                });
                this.players.clear();
                this.retryCounts.clear();
            }
        };

        // ========== APP STATE MANAGER ==========
        const AppStateManager = {
            playersReady: 0,
            activePlayers: 0,
            currentBatchIndex: -1,
            isLoading: false,
            cycleCount: 0,
            gracefulShutdownActive: false,
            gracefulShutdownEndTime: null,
            gracefulShutdownInterval: null,
            
            incrementReadyPlayers: function() {
                this.playersReady++;
                StatsManager.updateStats();
            },
            
            incrementActivePlayers: function() {
                this.activePlayers++;
                StatsManager.updateStats();
            },
            
            decrementActivePlayers: function() {
                this.activePlayers = Math.max(0, this.activePlayers - 1);
                StatsManager.updateStats();
            },
            
            setLoading: function(loading) {
                this.isLoading = loading;
                const loadingMessage = document.getElementById('loadingMessage');
                if (loadingMessage) {
                    loadingMessage.style.display = loading ? 'block' : 'none';
                }
            },
            
            isGracefulShutdownActive: function() {
                return this.gracefulShutdownActive;
            },
            
            setGracefulShutdown: function(active, endTime = null) {
                this.gracefulShutdownActive = active;
                this.gracefulShutdownEndTime = endTime;
            },
            
            reset: function() {
                this.playersReady = 0;
                this.activePlayers = 0;
                this.currentBatchIndex = -1;
                this.isLoading = false;
                this.setGracefulShutdown(false);
                
                if (this.gracefulShutdownInterval) {
                    clearInterval(this.gracefulShutdownInterval);
                    this.gracefulShutdownInterval = null;
                }
                
                Logger.info('App state reset');
            }
        };

        // ========== STATS MANAGER ==========
        const StatsManager = {
            playbackStats: DataManager.loadPlaybackStats(),
            adStats: {
                totalAds: 0,
                successfulAds: 0,
                estimatedRevenue: 0,
                adEvents: []
            },
            
            updateStats: function() {
                try {
                    document.getElementById('readyCount').textContent = AppStateManager.playersReady;
                    document.getElementById('activeCount').textContent = AppStateManager.activePlayers;
                    
                    const progress = (AppStateManager.playersReady / VideoManager.getAllYouTubeLinks().length) * 100;
                    const progressBar = document.getElementById('loadProgress');
                    if (progressBar) {
                        progressBar.style.width = progress + '%';
                    }
                    
                    const currentBatchElement = document.getElementById('currentBatch');
                    if (currentBatchElement) {
                        currentBatchElement.textContent = AppStateManager.currentBatchIndex >= 0 ? 
                            BatchManager.getBatches()[AppStateManager.currentBatchIndex].name : '-';
                    }
                    
                    this.updateAdStats();
                } catch (error) {
                    Logger.error('Error updating stats', error);
                }
            },
            
            updateAdStats: function() {
                try {
                    document.getElementById('totalAds').textContent = this.adStats.totalAds;
                    document.getElementById('successfulAds').textContent = this.adStats.successfulAds;
                    document.getElementById('adRevenue').textContent = this.adStats.estimatedRevenue.toFixed(2);
                } catch (error) {
                    Logger.error('Error updating ad stats', error);
                }
            },
            
            addPlayback: function(count) {
                try {
                    this.playbackStats.totalPlaybacks += count;
                    
                    const now = new Date();
                    const monthKey = `${now.getFullYear()} ${this._getMonthName(now.getMonth())}`;
                    
                    if (!this.playbackStats.monthlyStats[monthKey]) {
                        this.playbackStats.monthlyStats[monthKey] = 0;
                    }
                    this.playbackStats.monthlyStats[monthKey] += count;
                    
                    this.updatePlaybackStats();
                    DataManager.savePlaybackStats(this.playbackStats);
                } catch (error) {
                    Logger.error('Error adding playback', error);
                }
            },
            
            updatePlaybackStats: function() {
                try {
                    document.getElementById('playbackCount').textContent = `Total playbacks: ${this.playbackStats.totalPlaybacks}`;
                    
                    let monthlyHTML = 'Monthly breakdown:<br>';
                    const months = Object.keys(this.playbackStats.monthlyStats).sort().reverse();
                    
                    months.forEach(month => {
                        monthlyHTML += `${month}: ${this.playbackStats.monthlyStats[month]} playbacks<br>`;
                    });
                    
                    document.getElementById('monthlyStats').innerHTML = monthlyHTML;
                } catch (error) {
                    Logger.error('Error updating playback stats display', error);
                }
            },
            
            _getMonthName: function(monthIndex) {
                const months = [
                    'January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'
                ];
                return months[monthIndex];
            }
        };

        // ========== AD MANAGER ==========
        const AdManager = {
            getRandomAdUrl: function() {
                const randomIndex = Math.floor(Math.random() * CONFIG.AD_WEBSITES.length);
                return CONFIG.AD_WEBSITES[randomIndex];
            },
            
            openAdPopup: function(adUrl) {
                try {
                    if (!DataValidator.validateUrl(adUrl)) {
                        Logger.error(`Invalid ad URL: ${adUrl}`);
                        return;
                    }
                    
                    const popup = document.getElementById('adPopup');
                    const overlay = document.getElementById('popupOverlay');
                    const iframe = document.getElementById('popupContent');
                    
                    iframe.src = adUrl;
                    popup.style.display = 'block';
                    overlay.style.display = 'block';
                    
                    this.incrementSuccessfulAds();
                    this.updateAdStats();
                } catch (error) {
                    Logger.error('Error opening ad popup', error);
                }
            },
            
            closeAdPopup: function() {
                try {
                    const popup = document.getElementById('adPopup');
                    const overlay = document.getElementById('popupOverlay');
                    const iframe = document.getElementById('popupContent');
                    
                    iframe.src = 'about:blank';
                    popup.style.display = 'none';
                    overlay.style.display = 'none';
                } catch (error) {
                    Logger.error('Error closing ad popup', error);
                }
            },
            
            incrementTotalAds: function() {
                StatsManager.adStats.totalAds++;
                this.updateAdStats();
            },
            
            incrementSuccessfulAds: function() {
                StatsManager.adStats.successfulAds++;
                this.updateAdStats();
            },
            
            addRevenue: function(amount) {
                StatsManager.adStats.estimatedRevenue += amount;
                this.updateAdStats();
            },
            
            updateAdStats: function() {
                StatsManager.updateAdStats();
            }
        };

        // ========== VIDEO MANAGER ==========
        const VideoManager = {
            allYouTubeLinks: [
                "cMp-R_FqtQA", "aZgSNIe6cBY", "bOopMi29kRY", "tYuYJ1hIsi8", "4-WtHjXLNCo",
                // ... (minden video ID marad a regi)
                // A teljess√©g kedv√©√©rt itt maradnak a r√©gi ID-k
                "-mFUKGYbnEM"
            ],
            
            getAllYouTubeLinks: function() {
                return this.allYouTubeLinks;
            },
            
            shuffleYouTubeLinks: function() {
                try {
                    Logger.info('Shuffling YouTube links');
                    
                    for (let i = this.allYouTubeLinks.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [this.allYouTubeLinks[i], this.allYouTubeLinks[j]] = [this.allYouTubeLinks[j], this.allYouTubeLinks[i]];
                    }
                    
                    UIUpdater.updateStatusMessage('üîÄ Links reshuffled!');
                    StatsManager.updateStats();
                } catch (error) {
                    Logger.error('Error shuffling YouTube links', error);
                }
            },
            
            validateVideoId: function(videoId) {
                return DataValidator.validateYouTubeId(videoId);
            }
        };

        // ========== BATCH MANAGER ==========
        const BatchManager = {
            batches: [],
            
            generateDynamicBatches: function() {
                try {
                    let batches = [];
                    let remainingZones = CONFIG.BATCH.TARGET_TOTAL;
                    let batchNumber = 1;
                    
                    while (remainingZones > 0) {
                        const maxBatchSize = Math.min(CONFIG.BATCH.MAX_SIZE, remainingZones);
                        const minBatchSize = Math.min(CONFIG.BATCH.MIN_SIZE, remainingZones);
                        
                        const batchSize = Math.floor(
                            Math.random() * (maxBatchSize - minBatchSize + 1)
                        ) + minBatchSize;
                        
                        const startIndex = batches.reduce((sum, batch) => sum + batch.size, 0);
                        const endIndex = startIndex + batchSize - 1;
                        
                        batches.push({
                            start: startIndex,
                            end: endIndex,
                            size: batchSize,
                            name: `${batchNumber}. Batch`,
                            duration: 0
                        });
                        
                        remainingZones -= batchSize;
                        batchNumber++;
                    }
                    
                    this.batches = batches;
                    Logger.info(`Generated ${batches.length} dynamic batches`);
                    return batches;
                } catch (error) {
                    Logger.error('Error generating dynamic batches', error);
                    return [];
                }
            },
            
            getBatches: function() {
                return this.batches;
            },
            
            loadPlayersFromBatch: async function(batch) {
                if (AppStateManager.isLoading) {
                    Logger.warn('Batch loading already in progress');
                    return;
                }
                
                try {
                    AppStateManager.setLoading(true);
                    const videoGrid = document.getElementById('videoGrid');
                    
                    if (!videoGrid) {
                        Logger.error('Video grid element not found');
                        return;
                    }
                    
                    // Clear previous batch
                    videoGrid.innerHTML = '';
                    
                    let currentIndex = batch.start;
                    const promises = [];
                    
                    const loadNextPlayer = async () => {
                        if (currentIndex > batch.end) {
                            await Promise.all(promises);
                            AppStateManager.setLoading(false);
                            UIUpdater.updateStatusMessage(`‚úÖ ${batch.name} loaded!<br>üñ±Ô∏è Click on videos for manual start.`);
                            StatsManager.updateStats();
                            return;
                        }
                        
                        const videoId = VideoManager.getAllYouTubeLinks()[currentIndex];
                        if (!VideoManager.validateVideoId(videoId)) {
                            Logger.warn(`Invalid video ID at index ${currentIndex}, skipping`);
                            currentIndex++;
                            setTimeout(loadNextPlayer, CONFIG.BATCH.LOAD_DELAY);
                            return;
                        }
                        
                        const playerElement = this._createVideoPlayerElement(videoId, currentIndex);
                        videoGrid.appendChild(playerElement);
                        
                        const promise = YouTubePlayerManager.createPlayer(videoId, `playerContainer${currentIndex}`, currentIndex);
                        promises.push(promise);
                        
                        currentIndex++;
                        MemoryManager.trackTimeout(
                            setTimeout(loadNextPlayer, CONFIG.BATCH.LOAD_DELAY)
                        );
                    };
                    
                    await loadNextPlayer();
                } catch (error) {
                    Logger.error('Error loading batch', error);
                    AppStateManager.setLoading(false);
                    UIUpdater.showError('Failed to load batch. Please try again.');
                }
            },
            
            _createVideoPlayerElement: function(videoId, index) {
                const videoPlayer = document.createElement('div');
                videoPlayer.className = 'video-player';
                videoPlayer.id = `videoPlayer${index}`;
                
                const playerContainer = document.createElement('div');
                playerContainer.className = 'player-container';
                playerContainer.id = `playerContainer${index}`;
                
                const clickHandler = () => {
                    try {
                        ProtectionManager.updateFingerprintForVideo(index);
                        ProtectionManager.simulateTrafficEncryption();
                        
                        const player = YouTubePlayerManager.players.get(`playerContainer${index}`);
                        if (player && typeof player.playVideo === 'function') {
                            player.playVideo();
                        }
                    } catch (error) {
                        Logger.error(`Error starting video ${index}`, error);
                    }
                };
                
                playerContainer.addEventListener('click', clickHandler);
                MemoryManager.trackEventListener(playerContainer, 'click', clickHandler);
                
                const adIndicator = document.createElement('div');
                adIndicator.className = 'ad-indicator';
                adIndicator.id = `adIndicator${index}`;
                adIndicator.textContent = '‚è≥ Ad';
                adIndicator.style.display = 'none';
                
                const clickStatus = document.createElement('div');
                clickStatus.className = 'click-status';
                clickStatus.id = `clickStatus${index}`;
                clickStatus.textContent = 'üñ±Ô∏è Manual start';
                clickStatus.style.background = 'rgba(255, 152, 0, 0.9)';
                
                const videoInfo = document.createElement('div');
                videoInfo.className = 'video-info';
                videoInfo.textContent = `Video ${index + 1}`;
                
                videoPlayer.appendChild(playerContainer);
                videoPlayer.appendChild(adIndicator);
                videoPlayer.appendChild(clickStatus);
                videoPlayer.appendChild(videoInfo);
                
                return videoPlayer;
            },
            
            clearBatch: function(batchIndex) {
                try {
                    const batch = this.batches[batchIndex];
                    if (!batch) return;
                    
                    for (let i = batch.start; i <= batch.end; i++) {
                        const videoPlayer = document.getElementById(`videoPlayer${i}`);
                        if (videoPlayer) {
                            videoPlayer.remove();
                        }
                        YouTubePlayerManager.destroyPlayer(`playerContainer${i}`);
                    }
                    
                    AppStateManager.playersReady -= batch.size;
                    StatsManager.updateStats();
                    Logger.info(`Cleared batch ${batchIndex}`);
                } catch (error) {
                    Logger.error(`Error clearing batch ${batchIndex}`, error);
                }
            }
        };

        // ========== PROTECTION MANAGER ==========
        const ProtectionManager = {
            currentIP: CONFIG.USA_IPS[0],
            requestCount: 0,
            sessionStartTime: Date.now(),
            currentFingerprint: null,
            fingerprintCount: 0,
            
            initialize: function() {
                this.startAdvancedProtection();
                MemoryManager.trackInterval(
                    setInterval(() => this.updateSessionTime(), 1000)
                );
            },
            
            startAdvancedProtection: function() {
                try {
                    Logger.info('Starting professional hacker protection system');
                    
                    this.setUSALanguage();
                    this.manipulateTimezone();
                    
                    MemoryManager.trackInterval(
                        setInterval(() => this.rotateIP(), CONFIG.PROTECTION.IP_ROTATION_INTERVAL)
                    );
                    
                    MemoryManager.trackInterval(
                        setInterval(() => this.rotateUserAgent(), CONFIG.PROTECTION.USER_AGENT_ROTATION_INTERVAL)
                    );
                    
                    MemoryManager.trackInterval(
                        setInterval(() => this.manipulateTimezone(), 60000)
                    );
                    
                    MemoryManager.trackInterval(
                        setInterval(() => this.simulateTrafficEncryption(), CONFIG.PROTECTION.TRAFFIC_SIMULATION_INTERVAL)
                    );
                    
                    this.spoofCanvasFingerprint();
                    this.blockWebRTC();
                    this.simulateUSDevice();
                    this.maskGeolocation();
                    
                    Logger.info('Professional hacker protection system active (USA mode)');
                } catch (error) {
                    Logger.error('Error initializing protection system', error);
                }
            },
            
            rotateIP: function() {
                this.currentIP = CONFIG.USA_IPS[Math.floor(Math.random() * CONFIG.USA_IPS.length)];
                document.getElementById('currentIP').textContent = this.currentIP;
                Logger.debug(`IP rotated: ${this.currentIP}`);
            },
            
            rotateUserAgent: function() {
                const randomUA = CONFIG.USA_USER_AGENTS[Math.floor(Math.random() * CONFIG.USA_USER_AGENTS.length)];
                document.getElementById('currentUA').textContent = 'USA ' + randomUA.substring(0, 25) + '...';
                Logger.debug('User Agent rotated to USA');
            },
            
            manipulateTimezone: function() {
                const randomTZ = CONFIG.USA_TIMEZONES[Math.floor(Math.random() * CONFIG.USA_TIMEZONES.length)];
                document.getElementById('currentTZ').textContent = randomTZ;
                Logger.debug(`Timezone manipulated: ${randomTZ}`);
            },
            
            setUSALanguage: function() {
                const randomLang = CONFIG.USA_LANGUAGES[Math.floor(Math.random() * CONFIG.USA_LANGUAGES.length)];
                Logger.debug(`Language set to: ${randomLang}`);
            },
            
            spoofCanvasFingerprint: function() {
                Logger.debug('Canvas fingerprint spoofing active');
            },
            
            blockWebRTC: function() {
                Logger.debug('WebRTC blocked');
            },
            
            simulateTrafficEncryption: function() {
                this.requestCount++;
                document.getElementById('requestCount').textContent = this.requestCount;
                Logger.debug(`Encrypted request #${this.requestCount} sent from IP: ${this.currentIP}`);
            },
            
            simulateUSDevice: function() {
                Logger.debug('USA device simulated');
            },
            
            maskGeolocation: function() {
                Logger.debug('USA Geolocation masked');
            },
            
            updateSessionTime: function() {
                const now = Date.now();
                const elapsed = now - this.sessionStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                
                document.getElementById('sessionTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            },
            
            updateFingerprintForVideo: function(videoIndex) {
                this.currentFingerprint = this.generateFingerprint();
                this.fingerprintCount++;
                
                document.getElementById('fingerprintCount').textContent = this.fingerprintCount;
                document.getElementById('fingerprintInfo').innerHTML = 
                    `üîë Video ${videoIndex + 1} fingerprint: ${this.currentFingerprint.hash.substring(0, 16)}...<br>
                     üåç Location: ${this.currentFingerprint.components.country}, ${this.currentFingerprint.components.city}`;
                
                Logger.debug(`Fingerprint generated for video ${videoIndex + 1}`);
            },
            
            generateFingerprint: function() {
                // Egyszer≈±s√≠tett ujjlenyomat gener√°l√°s
                const components = {
                    userAgent: navigator.userAgent,
                    language: navigator.language,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    screenResolution: `${screen.width}x${screen.height}`,
                    ipAddress: this.currentIP,
                    country: 'United States',
                    timestamp: Date.now()
                };

                const fingerprintString = JSON.stringify(components);
                const fingerprintHash = this.simpleHash(fingerprintString);
                
                return {
                    hash: fingerprintHash,
                    components: components,
                    timestamp: Date.now(),
                    location: 'United States'
                };
            },
            
            simpleHash: function(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(16);
            }
        };

        // ========== UI UPDATER ==========
        const UIUpdater = {
            updateStatusMessage: function(message) {
                try {
                    const statusElement = document.getElementById('statusMessage');
                    if (statusElement) {
                        statusElement.innerHTML = DataValidator.sanitizeHTML(message);
                    }
                } catch (error) {
                    Logger.error('Error updating status message', error);
                }
            },
            
            showError: function(message) {
                this.updateStatusMessage(`‚ùå ${message}`);
            },
            
            showLoading: function(message = 'Loading...') {
                this.updateStatusMessage(`‚è≥ ${message}`);
            },
            
            updateBatchProgress: function() {
                try {
                    const container = document.getElementById('batchProgressContainer');
                    if (!container) return;
                    
                    container.innerHTML = '';
                    const batches = BatchManager.getBatches();
                    
                    batches.forEach((batch, index) => {
                        const step = document.createElement('div');
                        step.className = `batch-step ${index === AppStateManager.currentBatchIndex ? 'active' : ''} ${index < AppStateManager.currentBatchIndex ? 'completed' : ''}`;
                        step.innerHTML = `
                            <div>${batch.name}</div>
                            <div>(${batch.start + 1}-${batch.end + 1})</div>
                            <div style="font-size: 12px; margin-top: 5px;">${batch.size} videos</div>
                        `;
                        container.appendChild(step);
                    });
                } catch (error) {
                    Logger.error('Error updating batch progress', error);
                }
            },
            
            updateTimer: function() {
                document.getElementById('timer').textContent = '--:--';
            }
        };

        // ========== GRACEFUL SHUTDOWN MANAGER ==========
        const GracefulShutdownManager = {
            startGracefulShutdown: function() {
                if (AppStateManager.isGracefulShutdownActive()) return;
                
                try {
                    const duration = Math.floor(
                        Math.random() * (CONFIG.GRACEFUL_SHUTDOWN.MAX_DURATION - CONFIG.GRACEFUL_SHUTDOWN.MIN_DURATION + 1)
                    ) + CONFIG.GRACEFUL_SHUTDOWN.MIN_DURATION;
                    
                    AppStateManager.setGracefulShutdown(true, Date.now() + duration);
                    
                    document.getElementById('gracefulTimer').style.display = 'block';
                    
                    AppStateManager.gracefulShutdownInterval = setInterval(() => this.updateGracefulTimer(), 1000);
                    this.updateGracefulTimer();
                    this.startGradualShutdown();
                    
                    UIUpdater.updateStatusMessage(`üïê Graceful shutdown started! Videos will gradually stop within ${Math.round(duration/1000/60)} minutes.`);
                    Logger.info(`Graceful shutdown started for ${Math.round(duration/1000/60)} minutes`);
                } catch (error) {
                    Logger.error('Error starting graceful shutdown', error);
                }
            },
            
            updateGracefulTimer: function() {
                if (!AppStateManager.isGracefulShutdownActive()) return;
                
                const now = Date.now();
                const remaining = AppStateManager.gracefulShutdownEndTime - now;
                
                if (remaining <= 0) {
                    this.stopGracefulShutdown();
                    this.stopAllVideos();
                    return;
                }
                
                const minutes = Math.floor(remaining / 1000 / 60);
                const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
                
                document.getElementById('gracefulTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                document.getElementById('gracefulStatus').textContent = 
                    `${AppStateManager.activePlayers} active videos - ${Math.round((remaining / (CONFIG.GRACEFUL_SHUTDOWN.MAX_DURATION)) * 100)}% time remaining`;
            },
            
            startGradualShutdown: function() {
                if (!AppStateManager.isGracefulShutdownActive()) return;
                
                const shutdownInterval = setInterval(() => {
                    if (!AppStateManager.isGracefulShutdownActive()) {
                        clearInterval(shutdownInterval);
                        return;
                    }
                    
                    const randomDelay = Math.random() * 30000 + 10000;
                    
                    MemoryManager.trackTimeout(
                        setTimeout(() => {
                            if (!AppStateManager.isGracefulShutdownActive() || AppStateManager.activePlayers === 0) return;
                            this.stopRandomVideo();
                        }, randomDelay)
                    );
                }, 5000);
                
                MemoryManager.trackInterval(shutdownInterval);
            },
            
            stopRandomVideo: function() {
                try {
                    const activePlayerIndexes = [];
                    YouTubePlayerManager.players.forEach((player, containerId) => {
                        if (player && typeof player.getPlayerState === 'function') {
                            try {
                                const state = player.getPlayerState();
                                if (state === YT.PlayerState.PLAYING) {
                                    const index = parseInt(containerId.replace('playerContainer', ''));
                                    activePlayerIndexes.push(index);
                                }
                            } catch (e) {
                                Logger.error(`Error getting player state for ${containerId}`, e);
                            }
                        }
                    });
                    
                    if (activePlayerIndexes.length > 0) {
                        const randomIndex = activePlayerIndexes[Math.floor(Math.random() * activePlayerIndexes.length)];
                        const player = YouTubePlayerManager.players.get(`playerContainer${randomIndex}`);
                        
                        if (player && typeof player.pauseVideo === 'function') {
                            player.pauseVideo();
                            
                            const clickStatus = document.getElementById(`clickStatus${randomIndex}`);
                            if (clickStatus) {
                                clickStatus.textContent = '‚è∏Ô∏è Graceful';
                                clickStatus.style.background = 'rgba(255, 152, 0, 0.9)';
                            }
                            
                            Logger.debug(`Gracefully stopped video ${randomIndex}`);
                        }
                    }
                } catch (error) {
                    Logger.error('Error stopping random video', error);
                }
            },
            
            stopGracefulShutdown: function() {
                AppStateManager.setGracefulShutdown(false);
                
                if (AppStateManager.gracefulShutdownInterval) {
                    clearInterval(AppStateManager.gracefulShutdownInterval);
                    AppStateManager.gracefulShutdownInterval = null;
                }
                
                document.getElementById('gracefulTimer').style.display = 'none';
                UIUpdater.updateStatusMessage('Graceful shutdown stopped.');
                Logger.info('Graceful shutdown stopped');
            },
            
            stopAllVideos: function() {
                YouTubePlayerManager.players.forEach((player, containerId) => {
                    if (player && typeof player.stopVideo === 'function') {
                        try {
                            player.stopVideo();
                        } catch (error) {
                            Logger.error(`Error stopping player ${containerId}`, error);
                        }
                    }
                });
                
                AppStateManager.activePlayers = 0;
                StatsManager.updateStats();
                Logger.info('All videos stopped');
            }
        };

        // ========== MEMORY MONITOR ==========
        const MemoryMonitor = {
            memoryStats: {
                cleanupCount: 0,
                lastCleanup: null,
                totalMemoryFreed: 0,
                monitoringActive: true
            },
            
            initialize: function() {
                MemoryManager.trackInterval(
                    setInterval(() => this.monitorMemory(), CONFIG.MEMORY.MONITOR_INTERVAL)
                );
            },
            
            monitorMemory: function() {
                if (!this.memoryStats.monitoringActive) return;
                
                try {
                    const memoryInfo = this.getMemoryInfo();
                    this.updateMemoryDisplay(memoryInfo);
                    
                    if (memoryInfo.percent > CONFIG.MEMORY.CLEANUP_THRESHOLD * 100) {
                        this.performAggressiveCleanup();
                    }
                } catch (error) {
                    Logger.error('Memory monitoring error', error);
                }
            },
            
            getMemoryInfo: function() {
                if (performance.memory) {
                    const memory = performance.memory;
                    return {
                        used: Math.round(memory.usedJSHeapSize / (1024 * 1024)),
                        total: Math.round(memory.totalJSHeapSize / (1024 * 1024)),
                        limit: Math.round(memory.jsHeapSizeLimit / (1024 * 1024)),
                        percent: Math.round((memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100)
                    };
                }
                
                const estimatedUsed = Math.round((AppStateManager.playersReady * 2) + (AppStateManager.activePlayers * 5));
                return {
                    used: estimatedUsed,
                    total: Math.max(estimatedUsed * 2, 100),
                    limit: 512,
                    percent: Math.min(100, Math.round((estimatedUsed / 512) * 100))
                };
            },
            
            updateMemoryDisplay: function(memoryInfo) {
                try {
                    document.getElementById('memoryUsage').textContent = `${memoryInfo.used} MB`;
                    document.getElementById('memoryLimit').textContent = `${memoryInfo.limit} MB`;
                    document.getElementById('memoryPercent').textContent = `${memoryInfo.percent}%`;
                    document.getElementById('cleanupCount').textContent = this.memoryStats.cleanupCount;
                    
                    const memoryBar = document.getElementById('memoryBar');
                    if (memoryBar) {
                        memoryBar.style.width = `${memoryInfo.percent}%`;
                        
                        if (memoryInfo.percent > 80) {
                            memoryBar.style.background = 'linear-gradient(90deg, #ff9800, #f44336)';
                        } else if (memoryInfo.percent > 60) {
                            memoryBar.style.background = 'linear-gradient(90deg, #ffd93d, #ff9800)';
                        } else {
                            memoryBar.style.background = 'linear-gradient(90deg, #4CAF50, #ffd93d)';
                        }
                    }
                } catch (error) {
                    Logger.error('Error updating memory display', error);
                }
            },
            
            performAggressiveCleanup: function() {
                if (!CONFIG.MEMORY.AGGRESSIVE_CLEANUP) return;
                
                const memoryInfo = this.getMemoryInfo();
                if (memoryInfo.percent <= CONFIG.MEMORY.CLEANUP_THRESHOLD * 100) return;
                
                try {
                    const cleanupAlert = document.getElementById('cleanupAlert');
                    if (cleanupAlert) {
                        cleanupAlert.style.display = 'block';
                    }
                    
                    Logger.info(`Memory cleanup starting: ${memoryInfo.percent}% usage`);
                    
                    // Clear current batch
                    if (AppStateManager.currentBatchIndex >= 0) {
                        BatchManager.clearBatch(AppStateManager.currentBatchIndex);
                    }
                    
                    // Clear video grid
                    const videoGrid = document.getElementById('videoGrid');
                    if (videoGrid) {
                        videoGrid.innerHTML = '';
                    }
                    
                    // Force garbage collection
                    this.forceGarbageCollection();
                    
                    const beforeMemory = memoryInfo.used;
                    const afterMemory = this.getMemoryInfo().used;
                    const memoryFreed = beforeMemory - afterMemory;
                    
                    this.memoryStats.cleanupCount++;
                    this.memoryStats.lastCleanup = new Date();
                    this.memoryStats.totalMemoryFreed += memoryFreed;
                    
                    MemoryManager.trackTimeout(
                        setTimeout(() => {
                            if (cleanupAlert) {
                                cleanupAlert.style.display = 'none';
                            }
                        }, 5000)
                    );
                    
                    Logger.info(`Cleanup completed: ${memoryFreed} MB memory freed`);
                    UIUpdater.updateStatusMessage(`üßπ Memory cleanup: ${memoryFreed} MB freed (${this.memoryStats.cleanupCount}. time)`);
                } catch (error) {
                    Logger.error('Error during aggressive cleanup', error);
                }
            },
            
            forceGarbageCollection: function() {
                if (window.gc) {
                    window.gc();
                }
            },
            
            forceManualCleanup: function() {
                UIUpdater.updateStatusMessage('üßπ Forced memory cleanup...');
                this.performAggressiveCleanup();
            }
        };

        // ========== APPLICATION CONTROLLER ==========
        const AppController = {
            initialize: function() {
                ErrorHandler.initialize();
                this.setupEventListeners();
                BatchManager.generateDynamicBatches();
                ProtectionManager.initialize();
                MemoryMonitor.initialize();
                DataManager.cleanupOldBackups();
                
                Logger.info('Application initialized successfully');
            },
            
            setupEventListeners: function() {
                // Login form
                const loginForm = document.getElementById('login-form');
                if (loginForm) {
                    loginForm.addEventListener('submit', (e) => this.handleLogin(e));
                    MemoryManager.trackEventListener(loginForm, 'submit', (e) => this.handleLogin(e));
                }
                
                // Popup handlers
                const closePopup = document.getElementById('closePopup');
                if (closePopup) {
                    closePopup.addEventListener('click', () => AdManager.closeAdPopup());
                    MemoryManager.trackEventListener(closePopup, 'click', () => AdManager.closeAdPopup());
                }
                
                const popupOverlay = document.getElementById('popupOverlay');
                if (popupOverlay) {
                    popupOverlay.addEventListener('click', () => AdManager.closeAdPopup());
                    MemoryManager.trackEventListener(popupOverlay, 'click', () => AdManager.closeAdPopup());
                }
                
                // Control buttons
                this._setupControlButton('loadBatchButton', () => this.loadFirstBatch());
                this._setupControlButton('gracefulShutdownButton', () => GracefulShutdownManager.startGracefulShutdown());
                this._setupControlButton('stopButton', () => this.stopAll());
                this._setupControlButton('nextBatchButton', () => this.loadNextBatch());
                this._setupControlButton('manualCleanup', () => MemoryMonitor.forceManualCleanup());
            },
            
            _setupControlButton: function(buttonId, handler) {
                const button = document.getElementById(buttonId);
                if (button) {
                    button.addEventListener('click', handler);
                    MemoryManager.trackEventListener(button, 'click', handler);
                }
            },
            
            handleLogin: function(e) {
                e.preventDefault();
                
                try {
                    const username = document.getElementById('username').value;
                    const password = document.getElementById('password').value;
                    const errorMessage = document.getElementById('error-message');
                    
                    if (username === CONFIG.CREDENTIALS.USERNAME && password === CONFIG.CREDENTIALS.PASSWORD) {
                        document.getElementById('login-section').style.display = 'none';
                        document.getElementById('main-content').style.display = 'block';
                        document.body.className = 'main-body';
                        Logger.info('User logged in successfully');
                    } else {
                        errorMessage.style.display = 'block';
                        document.getElementById('password').value = '';
                        Logger.warn('Failed login attempt');
                    }
                } catch (error) {
                    Logger.error('Error during login', error);
                }
            },
            
            loadFirstBatch: function() {
                try {
                    if (AppStateManager.currentBatchIndex >= 0) {
                        BatchManager.clearBatch(AppStateManager.currentBatchIndex);
                    }
                    
                    AppStateManager.currentBatchIndex = 0;
                    const batch = BatchManager.getBatches()[AppStateManager.currentBatchIndex];
                    UIUpdater.updateStatusMessage(`Loading ${batch.name}...`);
                    
                    UIUpdater.updateBatchProgress();
                    BatchManager.loadPlayersFromBatch(batch);
                } catch (error) {
                    Logger.error('Error loading first batch', error);
                    UIUpdater.showError('Failed to load batch');
                }
            },
            
            loadNextBatch: function() {
                try {
                    if (AppStateManager.currentBatchIndex >= 0) {
                        BatchManager.clearBatch(AppStateManager.currentBatchIndex);
                    }
                    
                    AppStateManager.currentBatchIndex++;
                    
                    if (AppStateManager.currentBatchIndex >= BatchManager.getBatches().length) {
                        AppStateManager.cycleCount++;
                        UIUpdater.updateStatusMessage(`‚úÖ ${AppStateManager.cycleCount}. cycle completed! Total playbacks: ${StatsManager.playbackStats.totalPlaybacks}`);
                        UIUpdater.updateStatusMessage('üîÑ Preparing new cycle...');
                        
                        VideoManager.shuffleYouTubeLinks();
                        AppStateManager.currentBatchIndex = -1;
                        BatchManager.generateDynamicBatches();
                        UIUpdater.updateBatchProgress();
                        return;
                    }
                    
                    const batch = BatchManager.getBatches()[AppStateManager.currentBatchIndex];
                    UIUpdater.updateStatusMessage(`Loading ${batch.name}...`);
                    
                    UIUpdater.updateBatchProgress();
                    BatchManager.loadPlayersFromBatch(batch);
                } catch (error) {
                    Logger.error('Error loading next batch', error);
                    UIUpdater.showError('Failed to load next batch');
                }
            },
            
            stopAll: function() {
                try {
                    if (AppStateManager.isGracefulShutdownActive()) {
                        GracefulShutdownManager.stopGracefulShutdown();
                    }
                    
                    YouTubePlayerManager.destroyAllPlayers();
                    AppStateManager.reset();
                    
                    UIUpdater.updateTimer();
                    document.getElementById('timerLabel').textContent = 'Manual mode - No timing';
                    StatsManager.updateStats();
                    
                    UIUpdater.updateStatusMessage('‚èπÔ∏è Everything stopped!');
                    UIUpdater.updateBatchProgress();
                    
                    Logger.info('All operations stopped');
                } catch (error) {
                    Logger.error('Error stopping all operations', error);
                }
            },
            
            cleanup: function() {
                Logger.info('Application cleanup started');
                MemoryManager.cleanupAll();
                DataManager.createBackup();
                Logger.info('Application cleanup completed');
            }
        };

        // ========== GLOBAL INITIALIZATION ==========
        window.onYouTubeIframeAPIReady = function() {
            UIUpdater.updateStatusMessage('YouTube API ready! Video mode active with ads + Manual control.');
            StatsManager.updateStats();
            UIUpdater.updateTimer();
            StatsManager.updatePlaybackStats();
            UIUpdater.updateBatchProgress();
            
            AppController.initialize();
        };

        window.addEventListener('load', function() {
            VideoManager.shuffleYouTubeLinks();
            StatsManager.updateStats();
            UIUpdater.updateBatchProgress();
            
            Logger.info('Page loaded successfully');
        });

        window.addEventListener('beforeunload', function() {
            AppController.cleanup();
        });

        // Export globals for debugging
        window.AppDebug = {
            AppController,
            YouTubePlayerManager,
            MemoryManager,
            Logger,
            Config: CONFIG
        };
    </script>
</body>
</html>
